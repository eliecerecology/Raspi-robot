}
j = function() {a <<- a^2}
gene = list(h, e, j )
gene
sample(gene)
sample(gene)
sample(gene)
foo <- c(12, 22, 33)
names(foo) <- c("tic", "tac", "toe")
foo
names(foo)
foo(12)
foo <- c(12, 22, 33)
names(foo) <- c("tic", "tac", "toe")
foo
foo(tic)
foo$tic
foo["tac"]
foo["12"]
foo[12]
foo
foo = sample(foo)
foo
foo
foo
foo = sample(foo)
foo
names = sample(names(foo)
)
foo
names = sample(names(foo)
)
foo
foo = sample(foo)
names = sample(names(foo))
foo
foo = sample(foo)
names = sample(names(foo))
foo
foo <- c(12, 22, 33)
names(foo) <- c("tic", "tac", "toe")
rm(list=ls(all=TRUE)) #####Environments
my.env <- new.env()
logic = new.env()
frust = new.env()
h = function(a, b) {
if (a < b) { a <<- 3 } & {do.call(j,list() ) } else {print ("Hei you")}
} #& do.call(j, list())
e = function(a, b){
if (a == b){ c = 3 } else  if ( a > 3) {c = - 3} else { do.call(h, lista)}
}
j = function() {a <<- a^2}
lista = list(3,8)
lista = list(3,8)
do.call(e, lista)
environment(a)
environment(h)
environment(e)
environment(j)
environment(j)
frust$a
R_GlobalEnv$a
GlobalEnv$a
Global$a
a
h = function(a, b) {
if (a < b) { a <<- a } & {do.call(j,list() ) } else {print ("Hei you")}
} #& do.call(j, list())
e = function(a, b){
if (a == b){ c = 3 } else  if ( a > 3) {c = - 3} else { do.call(h, lista)}
}
j = function() {a <<- a^2}
rm(list=ls(all=TRUE)) #####Environments
h = function(a, b) {
if (a < b) { a <<- a } & {do.call(j,list() ) } else {print ("Hei you")}
} #& do.call(j, list())
e = function(a, b){
if (a == b){ c = 3 } else  if ( a > 3) {c = - 3} else { do.call(h, lista)}
}
j = function() {a <<- a^2}
lista = list(3,8)
environment(j)
do.call(e, lista)
a
reward = new.env(points)
ls(reward)
reward = new.env(points=as.numeric())
reward = new.env(points)
ls(reward)
reward = new.env()
ls(reward)
rm(list=ls(all=TRUE)) #####Environments
my.env <- new.env()
logic = new.env()
reward = new.env()
h = function(a, b) {
if (a < b) { a <<- a } & {do.call(j,list() ) } & {assign("points", 3, reward)} else {print ("Hei you")}
} #& do.call(j, list())
e = function(a, b){
if (a == b){ c = 3 } else  if ( a > 3) {c = - 3} else { do.call(h, lista)}
}
j = function() {a <<- a^2}
lista = list(3,8)
do.call(e, lista)
get("points", reward)
rm(list=ls(all=TRUE)) #####Environments
my.env <- new.env()
logic = new.env()
reward = new.env()
h = function(a, b) {
if (a < b) { a <<- a } & {do.call(j,list() ) } & {assign("points", points + 3, reward)} else {print ("Hei you")}
} #& do.call(j, list())
e = function(a, b){
if (a == b){ c = 3 } else  if ( a > 3) {c = - 3} & {assign("points", -2, reward)else { do.call(h, lista)}
}
j = function() {a <<- a^2}
lista = list(3,8)
h = function(a, b) {
if (a < b) { a <<- a } & {do.call(j,list() ) } & {assign("points", points + 3, reward)} else {print ("Hei you")}
} #& do.call(j, list())
e = function(a, b){
if (a == b){ c = 3 } else  if ( a > 3) {c = - 3}  else { do.call(h, lista)} & {assign("points", -2, reward)}
}
j = function() {a <<- a^2}
lista = list(3,8)
a
rm(list=ls(all=TRUE)) #####Environments
my.env <- new.env()
logic = new.env()
reward = new.env()
h = function(a, b) {
if (a < b) { a <<- 3 } & {do.call(j,list() ) } & {assign("points", points + 3, reward)} else {print ("Hei you")}
} #& do.call(j, list())
e = function(a, b){
if (a == b){ c = 3 } else  if ( a > 3) {c = - 3}  else { do.call(h, lista)} & {assign("points", -2, reward)}
}
j = function() {a <<- a^2}
lista = list(3,8)
do.call(e, lista)
rm(list=ls(all=TRUE)) #####Environments
my.env <- new.env()
logic = new.env()
reward = new.env()
#assign("h", if (a < b){ for(i in 1:3){logic$d[i] <- i}}, envir = logic)
h = function(a, b) {
if (a < b) { a <<- a } & {do.call(j,list() ) } & {reward$points = points + 3} else {print ("Hei you")}
} #& do.call(j, list())
e = function(a, b){
if (a == b){ c = 3 } else  if ( a > 3) {c = - 3}  else { do.call(h, lista)} & {assign("points", -2, reward)}
}
j = function() {a <<- a^2}
lista = list(3,8)
do.call(e, lista)
lista = list(3,8)
do.call(e, lista)
rm(list=ls(all=TRUE)) #####Environments
rm(list=ls(all=TRUE)) #####Environments
#my.env <- new.env()
#logic = new.env()
reward = new.env()
#assign("h", if (a < b){ for(i in 1:3){logic$d[i] <- i}}, envir = logic)
h = function(a, b) {
if (a < b) { a <<- a } & {do.call(j,list() ) } & {reward$points = a + 3} else {print ("Hei you")}
} #& do.call(j, list())
e = function(a, b){
if (a == b){ c = 3 } else  if ( a > 3) {c = - 3}  else { do.call(h, lista)} & {assign("points", -2, reward)}
}
j = function() {a <<- a^2}
lista = list(3,8)
a
do.call(e, lista)
a
get("points", reward)
reward$points
rm(list=ls(all=TRUE)) #####Environments
reward = new.env()
#assign("h", if (a < b){ for(i in 1:3){logic$d[i] <- i}}, envir = logic)
h = function(a, b) {
if (a < b) { a <<- a } & {do.call(j,list() ) } & {reward$points = a + 3} else {print ("Hei you")}
} #& do.call(j, list())
e = function(a, b){
if (a == b){ c = 3 } else  if ( a > 3) {c = - 3}  else { do.call(h, lista)} & {reward$points = -2)}
}
j = function() {a <<- a^2}
lista = list(3,8)
rm(list=ls(all=TRUE)) #####Environments
reward = new.env()
h = function(a, b) {
if (a < b) { a <<- a } & {do.call(j,list() ) } & {reward$points = a + 3} else {print ("Hei you")}
} #& do.call(j, list())
e = function(a, b){
if (a == b){ c = 3 } else  if ( a > 3) {c = - 3}  else { do.call(h, lista)} & {reward$points = -2}
}
j = function() {a <<- a^2}
lista = list(3,8)
a
do.call(e, lista)
reward$points
rm(list=ls(all=TRUE)) #####Environments
reward = new.env()
#assign("h", if (a < b){ for(i in 1:3){logic$d[i] <- i}}, envir = logic)
h = function(a, b) {
if (a < b) { a <<- a } & {do.call(j,list() ) } & {reward$points = reward$points + 3} else {print ("Hei you")}
} #& do.call(j, list())
e = function(a, b){
if (a == b){ c = 3 } else  if ( a > 3) {c = - 3}  else { do.call(h, lista)} & {reward$points = -2}
}
j = function() {a <<- a^2}
lista = list(3,8)
do.call(e, lista)
a
get("points", reward)
get("points", reward)
get("a", my.env)
points
rm(list=ls(all=TRUE)) #####Environments
reward = new.env()
h = function(a, b) {
if (a < b) { a <<- a } & {do.call(j,list() ) } & {reward$points = reward$points -1} else {print ("Hei you")}
} #& do.call(j, list())
e = function(a, b){
if (a == b){ c = 3 } else  if ( a > 3) {c = - 3}  else { do.call(h, lista)} & {reward$points = -2}
}
j = function() {a <<- a^2}
lista = list(3,8)
do.call(e, lista)
do.call(e, lista)
points
get("points", reward)
rm(list=ls(all=TRUE)) #####Environments
#my.env <- new.env()
#logic = new.env()
reward = new.env()
#assign("h", if (a < b){ for(i in 1:3){logic$d[i] <- i}}, envir = logic)
h = function(a, b) {
if (a < b) { a <<- a } & {do.call(j,list() ) } & {reward$points = -1} else {print ("Hei you")}
} #& do.call(j, list())
e = function(a, b){
if (a == b){ c = 3 } else  if ( a > 3) {c = - 3}  else { do.call(h, lista)} & {reward$points = -2}
}
j = function() {a <<- a^2}
lista = list(3,8)
do.call(e, lista)
get("points", reward)
rm(list=ls(all=TRUE)) #####Environments
#my.env <- new.env()
#logic = new.env()
reward = new.env()
#assign("h", if (a < b){ for(i in 1:3){logic$d[i] <- i}}, envir = logic)
h = function(a, b) {
if (a < b) { a <<- a } & {do.call(j,list() ) } & {reward$points = -1} else {print ("Hei you")}
} #& do.call(j, list())
e = function(a, b){
if (a == b){ c = 3 } else  if ( a > 3) {c = - 3}  else { do.call(h, lista)} & {reward$points = -9}
}
j = function() {a <<- a^2}
lista = list(3,8)
do.call(e, lista)
get("points", reward)
rm(list=ls(all=TRUE)) #####Environments
#my.env <- new.env()
#logic = new.env()
reward = new.env()
#assign("h", if (a < b){ for(i in 1:3){logic$d[i] <- i}}, envir = logic)
h = function(a, b) {
if (a < b) { a <<- a } & {do.call(j,list() ) } & {reward$points[1] = -1} else {print ("Hei you")}
} #& do.call(j, list())
e = function(a, b){
if (a == b){ c = 3 } else  if ( a > 3) {c = - 3}  else { do.call(h, lista)} & {reward$points = -9}
}
j = function() {a <<- a^2}
lista = list(3,8)
do.call(e, lista)
get("points", reward)
a
rm(list=ls(all=TRUE)) #####Environments
#my.env <- new.env()
#logic = new.env()
reward = new.env()
#assign("h", if (a < b){ for(i in 1:3){logic$d[i] <- i}}, envir = logic)
h = function(a, b) {
if (a < b) { a <<- a } & {do.call(j,list() ) } & {function() reward$points = reward$points -9} else {print ("Hei you")}
} #& do.call(j, list())
e = function(a, b){
if (a == b){ c = 3 } else  if ( a > 3) {c = - 3}  else { do.call(h, lista)} & {reward$points = -9}
}
j = function() {a <<- a^2}
lista = list(3,8)
do.call(e, lista)
do.call(e, lista)
rm(list=ls(all=TRUE)) #####Environments
#my.env <- new.env()
#logic = new.env()
reward = new.env()
#assign("h", if (a < b){ for(i in 1:3){logic$d[i] <- i}}, envir = logic)
h = function(a, b) {
if (a < b) { a <<- a } & {do.call(j,list() ) } & {assign("points", 4, reward)} else {print ("Hei you")}
} #& do.call(j, list())
e = function(a, b){
if (a == b){ c = 3 } else  if ( a > 3) {c = - 3}  else { do.call(h, lista)} & {reward$points = -9}
}
j = function() {a <<- a^2}
lista = list(3,8)
do.call(e, lista)
a
reward$points
get("points", reward)
rm(list=ls(all=TRUE)) #####Environments
#my.env <- new.env()
#logic = new.env()
reward = new.env()
#assign("h", if (a < b){ for(i in 1:3){logic$d[i] <- i}}, envir = logic)
h = function(a, b) {
if (a < b) { a <<- a } & {do.call(j,list() ) } & {assign("pointsi", 4, reward)} else {print ("Hei you")}
} #& do.call(j, list())
e = function(a, b){
if (a == b){ c = 3 } else  if ( a > 3) {c = - 3}  else { do.call(h, lista)} & {reward$points = -9}
}
j = function() {a <<- a^2}
lista = list(3,8)
do.call(e, lista)
a
get("pointsi", reward)
get("points", reward)
rm(list=ls(all=TRUE)) #####Environments
#my.env <- new.env()
#logic = new.env()
reward = new.env()
#assign("h", if (a < b){ for(i in 1:3){logic$d[i] <- i}}, envir = logic)
h = function(a, b) {
if (a < b) { a <<- a } & {do.call(j,list() ) } & {assign("pointsi", 4, reward)} else {print ("Hei you")}
} #& do.call(j, list())
e = function(a, b){
if (a == b){ c = 3 } else  if ( a > 3) {c = - 3}  else { do.call(h, lista)} & {reward$points = -9}
}
j = function() {a <<- a^2} & {reward$total = reward$points + reward$pointsi }
lista = list(3,8)
do.call(e, lista)
do.call(e, lista)
a
get("points", reward)
get("total", reward)
rm(list=ls(all=TRUE)) #####Environments
#my.env <- new.env()
#logic = new.env()
reward = new.env()
#assign("h", if (a < b){ for(i in 1:3){logic$d[i] <- i}}, envir = logic)
h = function(a, b) {
if (a < b) { a <<- a } & {do.call(j,list() ) } & {assign("pointsi", 4, reward)} else {print ("Hei you")}
} #& do.call(j, list())
e = function(a, b){
if (a == b){ c = 3 } else  if ( a > 3) {c = - 3}  else { do.call(h, lista)} & {reward$points = -9}
}
j = function() {a <<- a^2} & {reward$points = reward$points + reward$pointsi }
lista = list(3,8)
do.call(e, lista)
do.call(e, lista)
a
get("points", reward)
a
a = a + 1
a
library(plotrix)
row = 60; col = 60; span = 80; delay = 0.1
#re = sample(seq(from = 0, to = 1, by = 1), size = row*col, replace = TRUE)
j <- sapply(1:span, function(x) {
matrix(0, nrow = row, ncol = col)
}, simplify = FALSE)
j[[1]] <- matrix(0, nrow= row, ncol =col)
#j[[1]] <- edit(j[[1]])
j[[1]][35, 36] <- 1; j[[1]][36, 37] <- 1; j[[1]][37, 37] <- 1; j[[1]][37, 36] <- 1; j[[1]][37, 35] <- 1
j[[1]][1:col, 1]   <- 0
j[[1]][1, 1: row]  <- 0
j[[1]][1:row, col] <- 0
j[[1]][row, 1:col] <- 0
#color2D.matplot(j[[2]],c(0,1),c(0,0),c(0,0),show.legend=TRUE, show.values=F)
h <- sapply(1:span, function(x) {
matrix(0, nrow = row-2, ncol = col-2)
}, simplify = FALSE)
h_1 <- sapply(1:span, function(x) {
matrix(0, nrow = row-2, ncol = col-2)
}, simplify = FALSE)
a <- matrix(0, nrow = row -2)
b <- matrix(0, ncol = col)
testit <- function(x)
{
p1 <- proc.time()
Sys.sleep(x)
proc.time() - p1 # The cpu usage should be negligible
}
#h <- matrix(NaN, row - 2 , col - 2)
for (k in 1:span){
for (t in 1: (row-2)){
for (i in 1:(col-2)){
h_1[[k]][t, i] <- sum(j[[k]][t: (2 + t) , i : (2 + i) ] == 1) - j[[k]][t + 1, 1 + i] #sum(j[[k]][t + 1, 1 + i] == 1)
##1. Any live cell with fewer than two live neighbours dies, as if by needs caused by underpopulation.
if (j[[k]][t + 1, 1 + i] == 1 & h_1[[k]][t, i] < 2) {
h[[k]][t, i] <- 0}
##2. Any live cell with more than three live neighbours dies, as if by overcrowding.
else if (j[[k]][t + 1, 1 + i] == 1 & h_1[[k]][t, i] > 3) {
h[[k]][t, i] <- 0}
##3. Any live cell with two or three live neighbours lives, unchanged, to the next generation.
else if (j[[k]][t + 1, 1 + i] == 1 & h_1[[k]][t, i] == 2 | h_1[[k]][t, i] == 3 ) {
h[[k]][t, i] <- 1}
#4. Any dead cell with exactly three live neighbours will come to life.
else if (j[[k]][t + 1, 1 + i] == 0 & h_1[[k]][t, i] == 3 ) {
h[[k]][t, i] <- 1}
#else {h[[k]][t, i] <- 0}
}
print("2")
}
h[[k]] <- cbind(a, h[[k]], a)
h[[k]] <- rbind(b, h[[k]], b)
j[[k + 1]] <- h[[k]]
print("3")
#testit(0.3)
color2D.matplot(h[[k]],c(0,1),c(0,0),c(0,0),show.legend=TRUE, show.values=F)
testit(delay)
}
j[[1]] <- edit(j[[1]])
j[[1]][1:col, 1]   <- 0
j[[1]][1, 1: row]  <- 0
j[[1]][1:row, col] <- 0
j[[1]][row, 1:col] <- 0
#color2D.matplot(j[[2]],c(0,1),c(0,0),c(0,0),show.legend=TRUE, show.values=F)
h <- sapply(1:span, function(x) {
matrix(0, nrow = row-2, ncol = col-2)
}, simplify = FALSE)
h_1 <- sapply(1:span, function(x) {
matrix(0, nrow = row-2, ncol = col-2)
}, simplify = FALSE)
a <- matrix(0, nrow = row -2)
b <- matrix(0, ncol = col)
testit <- function(x)
{
p1 <- proc.time()
Sys.sleep(x)
proc.time() - p1 # The cpu usage should be negligible
}
#h <- matrix(NaN, row - 2 , col - 2)
for (k in 1:span){
for (t in 1: (row-2)){
for (i in 1:(col-2)){
h_1[[k]][t, i] <- sum(j[[k]][t: (2 + t) , i : (2 + i) ] == 1) - j[[k]][t + 1, 1 + i] #sum(j[[k]][t + 1, 1 + i] == 1)
##1. Any live cell with fewer than two live neighbours dies, as if by needs caused by underpopulation.
if (j[[k]][t + 1, 1 + i] == 1 & h_1[[k]][t, i] < 2) {
h[[k]][t, i] <- 0}
##2. Any live cell with more than three live neighbours dies, as if by overcrowding.
else if (j[[k]][t + 1, 1 + i] == 1 & h_1[[k]][t, i] > 3) {
h[[k]][t, i] <- 0}
##3. Any live cell with two or three live neighbours lives, unchanged, to the next generation.
else if (j[[k]][t + 1, 1 + i] == 1 & h_1[[k]][t, i] == 2 | h_1[[k]][t, i] == 3 ) {
h[[k]][t, i] <- 1}
#4. Any dead cell with exactly three live neighbours will come to life.
else if (j[[k]][t + 1, 1 + i] == 0 & h_1[[k]][t, i] == 3 ) {
h[[k]][t, i] <- 1}
#else {h[[k]][t, i] <- 0}
}
print("2")
}
h[[k]] <- cbind(a, h[[k]], a)
h[[k]] <- rbind(b, h[[k]], b)
j[[k + 1]] <- h[[k]]
print("3")
#testit(0.3)
color2D.matplot(h[[k]],c(0,1),c(0,0),c(0,0),show.legend=TRUE, show.values=F)
testit(delay)
}
j[[1]] <- edit(j[[1]])
h <- sapply(1:span, function(x) {
matrix(0, nrow = row-2, ncol = col-2)
}, simplify = FALSE)
h_1 <- sapply(1:span, function(x) {
matrix(0, nrow = row-2, ncol = col-2)
}, simplify = FALSE)
a <- matrix(0, nrow = row -2)
b <- matrix(0, ncol = col)
testit <- function(x)
{
p1 <- proc.time()
Sys.sleep(x)
proc.time() - p1 # The cpu usage should be negligible
}
#h <- matrix(NaN, row - 2 , col - 2)
for (k in 1:span){
for (t in 1: (row-2)){
for (i in 1:(col-2)){
h_1[[k]][t, i] <- sum(j[[k]][t: (2 + t) , i : (2 + i) ] == 1) - j[[k]][t + 1, 1 + i] #sum(j[[k]][t + 1, 1 + i] == 1)
##1. Any live cell with fewer than two live neighbours dies, as if by needs caused by underpopulation.
if (j[[k]][t + 1, 1 + i] == 1 & h_1[[k]][t, i] < 2) {
h[[k]][t, i] <- 0}
##2. Any live cell with more than three live neighbours dies, as if by overcrowding.
else if (j[[k]][t + 1, 1 + i] == 1 & h_1[[k]][t, i] > 3) {
h[[k]][t, i] <- 0}
##3. Any live cell with two or three live neighbours lives, unchanged, to the next generation.
else if (j[[k]][t + 1, 1 + i] == 1 & h_1[[k]][t, i] == 2 | h_1[[k]][t, i] == 3 ) {
h[[k]][t, i] <- 1}
#4. Any dead cell with exactly three live neighbours will come to life.
else if (j[[k]][t + 1, 1 + i] == 0 & h_1[[k]][t, i] == 3 ) {
h[[k]][t, i] <- 1}
#else {h[[k]][t, i] <- 0}
}
print("2")
}
h[[k]] <- cbind(a, h[[k]], a)
h[[k]] <- rbind(b, h[[k]], b)
j[[k + 1]] <- h[[k]]
print("3")
#testit(0.3)
color2D.matplot(h[[k]],c(0,1),c(0,0),c(0,0),show.legend=TRUE, show.values=F)
testit(delay)
}
